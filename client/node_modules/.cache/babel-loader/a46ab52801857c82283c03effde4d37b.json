{"ast":null,"code":"function getRow(matrix, j) {\n  if (!matrix[j]) {\n    matrix[j] = [];\n  }\n\n  return matrix[j];\n}\n\nfunction findFirstVacantIndex(row, x = 0) {\n  while (row[x]) {\n    x++;\n  }\n\n  return x;\n}\n\nfunction transposeInPlace(matrix, maxSize) {\n  for (let i = 0; i < maxSize; i++) {\n    const rowI = getRow(matrix, i);\n\n    for (let j = 0; j < i; j++) {\n      const rowJ = getRow(matrix, j);\n      const temp = rowI[j];\n      rowI[j] = rowJ[i];\n      rowJ[i] = temp;\n    }\n  }\n}\n\nfunction putCellIntoLayout(cell, layout, baseRow, baseCol) {\n  for (let r = 0; r < cell.rowspan; r++) {\n    const layoutRow = getRow(layout, baseRow + r);\n\n    for (let c = 0; c < cell.colspan; c++) {\n      layoutRow[baseCol + c] = cell;\n    }\n  }\n}\n\nfunction updateOffset(offsets, base, span, value) {\n  offsets[base + span] = Math.max(offsets[base + span] || 0, offsets[base] + value);\n}\n/**\n * @typedef { object } TablePrinterCell\n * Cell definition for the table printer.\n *\n * @property { number } colspan Number of columns this cell occupies.\n * @property { number } rowspan Number of rows this cell occupies.\n * @property { string } text Cell contents (pre-wrapped).\n */\n\n/**\n * Render a table into string.\n * Cells can contain multiline text and span across multiple rows and columns.\n *\n * Modifies cells to add lines array.\n *\n * @param { TablePrinterCell[][] } tableRows Table to render.\n * @param { number } rowSpacing Number of spaces between columns.\n * @param { number } colSpacing Number of empty lines between rows.\n * @returns { string }\n */\n\n\nfunction tableToString(tableRows, rowSpacing, colSpacing) {\n  const layout = [];\n  let colNumber = 0;\n  const rowNumber = tableRows.length;\n  const rowOffsets = [0]; // Fill the layout table and row offsets row-by-row.\n\n  for (let j = 0; j < rowNumber; j++) {\n    const layoutRow = getRow(layout, j);\n    const cells = tableRows[j];\n    let x = 0;\n\n    for (let i = 0; i < cells.length; i++) {\n      const cell = cells[i];\n      x = findFirstVacantIndex(layoutRow, x);\n      putCellIntoLayout(cell, layout, j, x);\n      x += cell.colspan;\n      cell.lines = cell.text.split('\\n');\n      const cellHeight = cell.lines.length;\n      updateOffset(rowOffsets, j, cell.rowspan, cellHeight + rowSpacing);\n    }\n\n    colNumber = layoutRow.length > colNumber ? layoutRow.length : colNumber;\n  }\n\n  transposeInPlace(layout, rowNumber > colNumber ? rowNumber : colNumber);\n  const outputLines = [];\n  const colOffsets = [0]; // Fill column offsets and output lines column-by-column.\n\n  for (let x = 0; x < colNumber; x++) {\n    let y = 0;\n    let cell;\n\n    while (y < rowNumber && (cell = layout[x][y])) {\n      if (!cell.rendered) {\n        let cellWidth = 0;\n\n        for (let j = 0; j < cell.lines.length; j++) {\n          const line = cell.lines[j];\n          const lineOffset = rowOffsets[y] + j;\n          outputLines[lineOffset] = (outputLines[lineOffset] || '').padEnd(colOffsets[x]) + line;\n          cellWidth = line.length > cellWidth ? line.length : cellWidth;\n        }\n\n        updateOffset(colOffsets, x, cell.colspan, cellWidth + colSpacing);\n        cell.rendered = true;\n      }\n\n      y += cell.rowspan;\n    }\n  }\n\n  return outputLines.join('\\n');\n}\n\nmodule.exports = {\n  tableToString: tableToString\n};","map":{"version":3,"sources":["D:/Documents/HKII_2020_2021/Tieu_Luan_CN/code/tlcn/client/node_modules/html-to-text/lib/table-printer.js"],"names":["getRow","matrix","j","findFirstVacantIndex","row","x","transposeInPlace","maxSize","i","rowI","rowJ","temp","putCellIntoLayout","cell","layout","baseRow","baseCol","r","rowspan","layoutRow","c","colspan","updateOffset","offsets","base","span","value","Math","max","tableToString","tableRows","rowSpacing","colSpacing","colNumber","rowNumber","length","rowOffsets","cells","lines","text","split","cellHeight","outputLines","colOffsets","y","rendered","cellWidth","line","lineOffset","padEnd","join","module","exports"],"mappings":"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","sourcesContent":["\nfunction getRow (matrix, j) {\n  if (!matrix[j]) { matrix[j] = []; }\n  return matrix[j];\n}\n\nfunction findFirstVacantIndex (row, x = 0) {\n  while (row[x]) { x++; }\n  return x;\n}\n\nfunction transposeInPlace (matrix, maxSize) {\n  for (let i = 0; i < maxSize; i++) {\n    const rowI = getRow(matrix, i);\n    for (let j = 0; j < i; j++) {\n      const rowJ = getRow(matrix, j);\n      const temp = rowI[j];\n      rowI[j] = rowJ[i];\n      rowJ[i] = temp;\n    }\n  }\n}\n\nfunction putCellIntoLayout (cell, layout, baseRow, baseCol) {\n  for (let r = 0; r < cell.rowspan; r++) {\n    const layoutRow = getRow(layout, baseRow + r);\n    for (let c = 0; c < cell.colspan; c++) {\n      layoutRow[baseCol + c] = cell;\n    }\n  }\n}\n\nfunction updateOffset (offsets, base, span, value) {\n  offsets[base + span] = Math.max(\n    offsets[base + span] || 0,\n    offsets[base] + value\n  );\n}\n\n/**\n * @typedef { object } TablePrinterCell\n * Cell definition for the table printer.\n *\n * @property { number } colspan Number of columns this cell occupies.\n * @property { number } rowspan Number of rows this cell occupies.\n * @property { string } text Cell contents (pre-wrapped).\n */\n\n/**\n * Render a table into string.\n * Cells can contain multiline text and span across multiple rows and columns.\n *\n * Modifies cells to add lines array.\n *\n * @param { TablePrinterCell[][] } tableRows Table to render.\n * @param { number } rowSpacing Number of spaces between columns.\n * @param { number } colSpacing Number of empty lines between rows.\n * @returns { string }\n */\nfunction tableToString (tableRows, rowSpacing, colSpacing) {\n  const layout = [];\n  let colNumber = 0;\n  const rowNumber = tableRows.length;\n  const rowOffsets = [0];\n  // Fill the layout table and row offsets row-by-row.\n  for (let j = 0; j < rowNumber; j++) {\n    const layoutRow = getRow(layout, j);\n    const cells = tableRows[j];\n    let x = 0;\n    for (let i = 0; i < cells.length; i++) {\n      const cell = cells[i];\n      x = findFirstVacantIndex(layoutRow, x);\n      putCellIntoLayout(cell, layout, j, x);\n      x += cell.colspan;\n      cell.lines = cell.text.split('\\n');\n      const cellHeight = cell.lines.length;\n      updateOffset(rowOffsets, j, cell.rowspan, cellHeight + rowSpacing);\n    }\n    colNumber = (layoutRow.length > colNumber) ? layoutRow.length : colNumber;\n  }\n\n  transposeInPlace(layout, (rowNumber > colNumber) ? rowNumber : colNumber);\n\n  const outputLines = [];\n  const colOffsets = [0];\n  // Fill column offsets and output lines column-by-column.\n  for (let x = 0; x < colNumber; x++) {\n    let y = 0;\n    let cell;\n    while (y < rowNumber && (cell = layout[x][y])) {\n      if (!cell.rendered) {\n        let cellWidth = 0;\n        for (let j = 0; j < cell.lines.length; j++) {\n          const line = cell.lines[j];\n          const lineOffset = rowOffsets[y] + j;\n          outputLines[lineOffset] = (outputLines[lineOffset] || '').padEnd(colOffsets[x]) + line;\n          cellWidth = (line.length > cellWidth) ? line.length : cellWidth;\n        }\n        updateOffset(colOffsets, x, cell.colspan, cellWidth + colSpacing);\n        cell.rendered = true;\n      }\n      y += cell.rowspan;\n    }\n  }\n\n  return outputLines.join('\\n');\n}\n\nmodule.exports = { tableToString: tableToString };\n"]},"metadata":{},"sourceType":"script"}